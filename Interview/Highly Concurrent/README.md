# 高并发

## 🔥 1️⃣ **应用层面（代码 & JVM 优化）**

### ✅ **1.1 连接池优化**

- **数据库连接池**：调整最大连接数、最小空闲数，合理配置（如 Druid、HikariCP）。
- **线程池优化**：调整核心线程数、队列大小、拒绝策略，防止线程堆积或频繁上下文切换。

### ✅ **1.2 减少锁粒度 / 使用无锁结构**

- 减少 `synchronized` 范围，避免**粗粒度锁**。
- 引入 **乐观锁**（版本号、CAS机制），代替悲观锁。
- 使用 **并发集合**（`ConcurrentHashMap`、`CopyOnWriteArrayList`）。

### ✅ **1.3 JVM 调优**

- 合理设置 **堆大小 (Xmx/Xms)**。
- 调整 **GC 策略**，如 G1 GC 适合低延迟场景。
- 监控 JVM Full GC 频率，避免频繁垃圾回收。



## 🔥 2️⃣ **缓存层优化**

### ✅ **2.1 引入缓存**

- 使用 **本地缓存**（如 Guava Cache、Caffeine）减少 DB 访问。
- 使用 分布式缓存（如 Redis、Memcached）：
  - 热点数据提前缓存
  - 设置合理的过期时间

### ✅ **2.2 缓存热点&穿透问题**

- **热点数据**：设置合理的 TTL + **互斥锁防止缓存雪崩**。
- **缓存穿透**：针对不存在的 key，缓存空值或用 BloomFilter 拦截。



## 🔥 3️⃣ **数据库层优化**

### ✅ **3.1 SQL 优化**

- 避免 **全表扫描**，加合适索引。
- 分页查询时优化 **`limit` 偏移量**。
- 控制一次查询的返回量，避免大 ResultSet。

### ✅ **3.2 数据库分库分表**

- **分库分表**减小单库压力。
- 配合 **分布式中间件**（如 ShardingSphere、MyCat）。

### ✅ **3.3 读写分离**

- 主库写、从库读，缓解主库压力。

------

## 🔥 4️⃣ **架构层面**

### ✅ **4.1 服务拆分 & 微服务化**

- 将**单体应用拆分**，每个模块独立部署，解耦后并行扩展。

### ✅ **4.2 负载均衡**

- Nginx、LVS、服务注册中心（如 Nacos）实现请求均衡分发。

### ✅ **4.3 限流&熔断**

- **限流**（如 Token Bucket、漏桶算法）：防止突发请求打挂系统。
- **熔断**（Hystrix、Resilience4j）：保护下游服务。

------

## 🔥 5️⃣ **异步化 & 消息队列**

### ✅ **5.1 异步处理**

- 使用 **线程池异步执行耗时任务**，减少接口 RT

### ✅ **5.2 消息队列削峰填谷**

- 接入 MQ（Kafka、RabbitMQ、RocketMQ）缓冲瞬时高并发请求
- 订单、支付、日志、通知类场景中常用

------

## 🔥 6️⃣ **CDN + 静态资源优化**

- 图片、静态页面、视频等资源通过 CDN 缓存，减轻源站压力。
- API 网关限流、防刷保护。